const Product = require("../models/product");



const getLetherProducts = async (req, res) => {

  try {
    const { id, page = 1, limit = 15, subcatory } = req.query;
    const { category } = req.params;
    const categorisOne = "leather";

    // ✅ Base filter
    let filter = { categorisOne };
    console.log(categorisOne,category,subcatory)

    // ✅ If main category provided (like "classic", "sports", etc.)
    if (category) {
      filter.subcategory = { $in: [category] };
    }

    // ✅ If subcatory query param also provided
    // if (subcatory) {
    //   filter.subcategory = { $in: [subcatory] };
    // }

    // ✅ If searching by product ID
    if (id) {
      const product = await Product.findById(id);

      if (!product) {
        return res.status(404).json({ message: "❌ Product not found" });
      }

      if (product.categorisOne !== categorisOne) {
        return res.status(400).json({ message: "❌ Product is not a watch" });
      }

      return res.json(product);
    }

    // ✅ Convert pagination numbers
    const pageNum = parseInt(page, 10);
    const limitNum = parseInt(limit, 10);

    // ✅ Count total products
    const totalProducts = await Product.countDocuments(filter);


    // ✅ Fetch paginated products
    const products = await Product.find(filter)
      .skip((pageNum - 1) * limitNum)
      .limit(limitNum);

    return res.json({
      totalProducts,
      totalPages: Math.ceil(totalProducts / limitNum),
      currentPage: pageNum,
      products,
    });
  } catch (err) {
    res.status(500).json({
      message: "❌ Error fetching watches",
      error: err.message,
    });
  }
};


// ---------------- Add Leather Goods ----------------
const addLeathergoods = async (req, res) => {
  try {
    const {
      MainCategory,
      SubCategory,
      Brand,
      Model,
      modelCode,
      additionalTitle,
      serialNumber,
      sku,
      productionYear,
      approximateYear,
      unknownYear,
      gender,
      Material,
      interiorMaterial,
      Color,
      hardwareColor,
      condition,
      itemCondition,
      conditionNotes,
      size,
      strapLength,
      accessoriesAndDelivery,
      scopeOfDeliveryOptions,
      taxStatus,
      stockQuantity,
      inStock,
      badges,
      images,
      seoTitle,
      seoDescription,
      seoKeywords,
      retailPrice,
      sellingPrice,
      description,
    } = req.body;

    // Handle unknown year
    const finalProductionYear = unknownYear ? "unknown" : productionYear;

    // Auto-set category based on MainCategory
    let category = "Leather Goods";
    if (MainCategory === "Hand Bag" || MainCategory === "Briefcase" || MainCategory === "Pouch") {
      category = "Leather Bags";
    }

    // Generate automatic product name
    const generateProductName = () => {
      const nameParts = [];
      
      // Add Brand
      if (Brand) nameParts.push(Brand);
      
      // Add Model
      if (Model) nameParts.push(Model);

      if(MainCategory) nameParts.push(MainCategory)
   
      
      return nameParts.join(' ');
    };

    const autoGeneratedName = generateProductName();

    const newLeather = new Product({
      // Basic product fields
      category,
      brand: Brand,
      model: Model,
      name: autoGeneratedName, // Auto-generated name
      
      // Leather goods specific fields
      leatherMainCategory: MainCategory, // Map to schema field
      leatherSubCategory: SubCategory,    // Map to schema field
      modelCode,
      additionalTitle,
      serialNumber,
      sku,

      productionYear: finalProductionYear,
      approximateYear,
      unknownYear,

      gender,
      leatherMaterial: Material, // Map to schema field
      interiorMaterial,
      dialColor: Color, // Using dialColor for Color (common field)
      hardwareColor,

      condition,
      itemCondition,
      conditionNotes,

      leatherSize: size ? { // Map to schema field
        width: size.width || undefined,
        height: size.height || undefined,
        depth: size.depth || undefined,
      } : undefined,

      strapLength,

      leatherAccessories: accessoriesAndDelivery, // Map to schema field
      leatherScopeOfDelivery: scopeOfDeliveryOptions, // Map to schema field

      taxStatus,
      stockQuantity: stockQuantity || 0,
      inStock: inStock !== undefined ? inStock : true,

      badges: badges || [],
      images: images || [],

      seoTitle,
      seoDescription,
      seoKeywords,

      // Pricing - use both naming conventions for compatibility
      retailPrice,
      sellingPrice,
      regularPrice: retailPrice,
      salePrice: sellingPrice,

      description,
      
      // Set published status
      published: true,
    });

    const savedLeather = await newLeather.save();

    res.status(201).json({
      success: true,
      message: "Leather goods added successfully",
      data: savedLeather,
    });
  } catch (error) {
    console.error("Error adding leather goods:", error);
    res.status(500).json({
      success: false,
      message: "Server error, could not add leather goods",
      error: error.message,
    });
  }
};

// ---------------- Update Leather Goods ----------------
const updateLeathergoods = async (req, res) => {
  try {
    const leatherId = req.params.id;

    const allowedUpdates = [
      "MainCategory",
      "SubCategory",
      "Brand",
      "Model",
      "modelCode",
      "additionalTitle",
      "serialNumber",
      "sku",
      "productionYear",
      "approximateYear",
      "unknownYear",
      "gender",
      "Material",
      "interiorMaterial",
      "Color",
      "hardwareColor",
      "condition",
      "itemCondition",
      "conditionNotes",
      "size",
      "strapLength",
      "accessoriesAndDelivery",
      "scopeOfDeliveryOptions",
      "taxStatus",
      "stockQuantity",
      "inStock",
      "badges",
      "images",
      "seoTitle",
      "seoDescription",
      "seoKeywords",
      "retailPrice",
      "sellingPrice",
      "description",
    ];

    const updateData = {};
    allowedUpdates.forEach((field) => {
      if (req.body[field] !== undefined) {
        // Map fields to schema field names
        if (field === "Brand") updateData.brand = req.body[field];
        else if (field === "Model") updateData.model = req.body[field];
        else if (field === "MainCategory") updateData.leatherMainCategory = req.body[field];
        else if (field === "SubCategory") updateData.leatherSubCategory = req.body[field];
        else if (field === "Material") updateData.leatherMaterial = req.body[field];
        else if (field === "Color") updateData.dialColor = req.body[field];
        else if (field === "accessoriesAndDelivery") updateData.leatherAccessories = req.body[field];
        else if (field === "scopeOfDeliveryOptions") updateData.leatherScopeOfDelivery = req.body[field];
        else updateData[field] = req.body[field];
      }
    });

    // Handle category update based on MainCategory
    if (updateData.leatherMainCategory) {
      if (updateData.leatherMainCategory === "Hand Bag" || updateData.leatherMainCategory === "Briefcase" || updateData.leatherMainCategory === "Pouch") {
        updateData.category = "Leather Bags";
      } else {
        updateData.category = "Leather Goods";
      }
    }

    // Unknown year logic
    if (updateData.unknownYear === true) {
      updateData.productionYear = "unknown";
      updateData.approximateYear = false;
    } else if (updateData.unknownYear === false && updateData.productionYear) {
      updateData.productionYear = updateData.productionYear;
    }

    // Update nested size object properly
    if (req.body.size) {
      updateData.leatherSize = {
        width: req.body.size.width !== undefined ? req.body.size.width : undefined,
        height: req.body.size.height !== undefined ? req.body.size.height : undefined,
        depth: req.body.size.depth !== undefined ? req.body.size.depth : undefined,
      };
    }

    // Sync pricing fields
    if (updateData.retailPrice !== undefined) {
      updateData.regularPrice = updateData.retailPrice;
    }
    if (updateData.sellingPrice !== undefined) {
      updateData.salePrice = updateData.sellingPrice;
    }

    // Auto-generate name if relevant fields are updated
    const nameUpdateFields = ['Brand', 'Model', 'MainCategory', 'SubCategory', 'additionalTitle', 'Color', 'Material'];
    const shouldUpdateName = nameUpdateFields.some(field => req.body[field] !== undefined);
    
    if (shouldUpdateName) {
      // Get current product data to generate new name
      const currentProduct = await Product.findById(leatherId);
      if (currentProduct) {
        const updatedBrand = updateData.brand || currentProduct.brand;
        const updatedModel = updateData.model || currentProduct.model;
        const updatedMainCategory = updateData.MainCategory || currentProduct.MainCategory

        const generateUpdatedName = () => {
          const nameParts = [];
          
          if (updatedBrand) nameParts.push(updatedBrand);
          if (updatedModel) nameParts.push(updatedModel);
          if (updatedMainCategory) nameParts.push(updatedMainCategory);
        
          return nameParts.join(' ');
        };

        updateData.name = generateUpdatedName();
      }
    }

    const updatedLeather = await Product.findByIdAndUpdate(
      leatherId,
      updateData,
      { new: true, runValidators: true }
    );

    if (!updatedLeather) {
      return res.status(404).json({
        success: false,
        message: "Leather goods not found",
      });
    }

    const responseLeather = updatedLeather.toObject();
    
    // Handle unknown year in response
    if (responseLeather.unknownYear === true) {
      responseLeather.productionYear = "unknown";
    }

    res.status(200).json({
      success: true,
      message: "Leather goods updated successfully",
      data: responseLeather,
    });
  } catch (error) {
    console.error("Error updating leather goods:", error);
    res.status(500).json({
      success: false,
      message: "Server error, could not update leather goods",
      error: error.message,
    });
  }
};

module.exports = { getLetherProducts, addLeathergoods, updateLeathergoods };